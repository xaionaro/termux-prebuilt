<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8" />
<title>Errors - Vala Reference Manual</title>
<link rel="stylesheet" type="text/css" href="default.css"><meta name="viewport" content="initial-scale=1">
</head>
<body>
<div class="o-fixedtop c-navbar"><div class="o-navbar">
<span class="c-pageturner u-float-left"><a href="index.html">Contents</a></span><span>Vala Reference Manual</span><div class="u-float-right">
<span class="c-pageturner o-inlinewidth-4"><a href="Delegates.html">Prev</a></span><span class="c-pageturner o-inlinewidth-4"><a href="Classes.html">Next</a></span>
</div>
</div></div>
<h2>9. Errors</h2>
<ul class="page_toc">
<li><a href="Errors.html#Error_throwing">9.1 Error throwing</a></li>
<li><a href="Errors.html#Error_catching">9.2 Error catching</a></li>
<li><a href="Errors.html#Examples">9.3 Examples</a></li>
</ul>
<p>Vala Error handling is just for recoverable runtime errors, anything that can be reasonably foreseen should not be handled with errors, e.g. passing the wrong args to a method.  In that example, a better action is to state that the method's result is undefined on illegal input, and use method contracts or assertions to catch potential problems during development: See <a href="http://wiki.gnome.org/Projects/Vala/Manual/Export/Projects/Vala/Manual/Methods#Contract_programming">Methods/Contract programming</a>.  A more suitable use for errors would be reporting missing files, which of course cannot be detected until the program is running. </p>
<p>A method may declare that it throws methods from any number of error domains.  Error domains are groups of related errors, each of which is denoted by a unique symbol in much the same way an enumerated type, see <a href="http://wiki.gnome.org/Projects/Vala/Manual/Export/Projects/Vala/Manual/Enumerated%20types%20%28Enums%29#Error_domains">Enumerated types (Enums)/Error domains</a> for declaration syntax.  In Vala it is not allowed to throw arbitrary data as in C++, and there is no class for errors, as in Java. </p>
<p>No error can be thrown must either be caught or declared as being thrown. </p>
<p>When a method declares it may thrown an error, the invoker may choose to either catch the error (should one be thrown), or ignore it, meaning it will be thrown on to that methods caller.  In the latter case, the method failing to catch the error must also be declared to throw that type of error.  Errors can only be caught when the method throwing it is invoked within the try block of a try statement.  A try statement, with its associated catch blocks, can potentially catch all errors thrown in its scope, either with catch blocks for all error domains from which a thrown error might come, or with a generic catch block to catch any error. </p>
<p>When an error is first thrown, the "throw" statement is considered the same as a method which from which an error has been thrown.  This means that it is possible to catch errors locally, but this is not good practise.  The only proper use of this functionality is to use a finally block to free resources before the error is thrown from the method. </p>
<p>When an error is thrown, the following sequence of events happens: </p>
<p>NB: finally clauses are always run, regardless of if error is thrown and/or handled. </p>

<h3 id="Error_throwing">9.1 Error throwing</h3>
<p>Throwing an error is done with the following syntax: </p>
<blockquote class="o-box c-rules">throw-statement:
	<span class="literal">throw</span> error-description <span class="literal">;</span>

error-description:
	identifier
	error-creation-expression

error-creation-expression:
	<span class="literal">new</span> qualified-error-type <span class="literal">(</span> message-expression <span class="literal">)</span>

qualified-error-type:
	qualified-error-domain <span class="literal">.</span> error-type

qualified-error-domain:
	[ qualified-namespace-name <span class="literal">.</span> ] error-domain-name

</blockquote>
<p>That is, throw an error that has already been created and can be identified by a name, or a new error created with a textual description.  The message-expression is any expression that evaluates to a instance of the string type. </p>

<h3 id="Error_catching">9.2 Error catching</h3>
<p>The syntax of the try statement: </p>
<blockquote class="o-box c-rules">try-statement:
	<span class="literal">try</span> statement-block catch-clauses
	<span class="literal">try</span> statement-block [catch-clauses] finally-clause

catch-clauses:
	[ specific-catch-clauses ] general-catch-clause

specific-catch-clauses:
	specific-catch-clause
	[ specific-catch-clauses ]

specific-catch-clause:
	<span class="literal">catch</span><span class="literal">(</span> qualified-error-type identifier <span class="literal">)</span> statement-block

general-catch-clause:
	<span class="literal">catch</span> statement-block

finally-clause:
	<span class="literal">finally</span> statement-block

</blockquote>
<p>In the statement block scope of each catch clause, the error is assigned to a variable with the identifier given. </p>

<h3 id="Examples">9.3 Examples</h3>
<p>Demonstrating... </p>
<pre class="o-box c-program"><span class="c-program-token">errordomain</span> <span class="c-program-methodname">ErrorType1</span> {
    <span class="c-program-methodname">CODE_1A</span>
}

<span class="c-program-token">errordomain</span> <span class="c-program-methodname">ErrorType2</span> {
    <span class="c-program-methodname">CODE_2A</span>
}

<span class="c-program-token">public</span> <span class="c-program-token">class</span> <span class="c-program-methodname">Test</span> : <span class="c-program-methodname">GLib</span>.<span class="c-program-methodname">Object</span> {
    <span class="c-program-token">public</span> <span class="c-program-token">static</span> <span class="c-program-token">void</span> <span class="c-program-methodname">thrower</span>() <span class="c-program-token">throws</span> <span class="c-program-methodname">ErrorType1</span>, <span class="c-program-methodname">ErrorType2</span> {
        <span class="c-program-token">throw</span> <span class="c-program-token">new</span> <span class="c-program-methodname">ErrorType2</span>.<span class="c-program-methodname">CODE_1A</span>(<span class="c-program-phrase">"</span><span class="c-program-phrase">Error</span><span class="c-program-phrase">"</span>);
    }

    <span class="c-program-token">public</span> <span class="c-program-token">static</span> <span class="c-program-token">void</span> <span class="c-program-methodname">catcher</span>() <span class="c-program-token">throws</span> <span class="c-program-methodname">ErrorType2</span> {
        <span class="c-program-token">try</span> {
            <span class="c-program-methodname">thrower</span>();
        } <span class="c-program-token">catch</span> (<span class="c-program-methodname">ErrorType1</span> <span class="c-program-methodname">ex</span>) {
            <span class="c-program-comment">// Deal with ErrorType1 </span>
<span class="c-program-comment"></span>        } <span class="c-program-token">finally</span> {
            <span class="c-program-comment">// Tidy up</span>
<span class="c-program-comment"></span>        }
    }

    <span class="c-program-token">public</span> <span class="c-program-token">static</span> <span class="c-program-token">void</span> <span class="c-program-methodname">main</span>(<span class="c-program-token">string</span>[] <span class="c-program-methodname">args</span>) {
        <span class="c-program-token">try</span> {
            <span class="c-program-methodname">catcher</span>();
        } <span class="c-program-token">catch</span> (<span class="c-program-methodname">ErrorType2</span> <span class="c-program-methodname">ex</span>) {
            <span class="c-program-comment">// Deal with ErrorType2</span>
<span class="c-program-comment"></span>        }
    }
}
</pre>
</body>
</html>
